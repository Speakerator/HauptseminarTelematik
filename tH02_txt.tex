\documentclass{semdoc}
\usepackage{lipsum} 
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage{textcomp}
%allow the use of the todo command 
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%allow the use of the \cite{NEEDED} command
\usepackage{ifthen}
\let\oldcite=\cite
\renewcommand\cite[1]{\ifthenelse{\equal{#1}{NEEDED}}{[citation~needed]}{\oldcite{#1}}}



\docbegin

\title{Recent Advances in Sandboxing}
\author{Christoph Heidrich}
\authorURL{christop.heidrich@tu-ilmenau.de}

\maketitle
% initial config
\nocite{*}
\begin{abstract}
\{ Insert Abstract here\}
\end{abstract}

% --> Im Text sollte \section der "h�chste" Gliederungsbefehl sein,
%     Bitte _neue_ Rechtschreibung verwenden!
%     kein include, input newpage oder \\
%
%	  Auf Zeilenimbr�che alle 80 Zeichen achten
%	  Rechtschreibung pr�fen!
%     Men�: Edit -> Spell -> Select Deutsch8, dann Edit -> Spell -> Check Buffer)

%\todo{The original todo note withouth changed colours.\newline Here's another line.}
%\lipsum[11]\unsure{Is this correct?}\unsure{I'm unsure about also!}
%\lipsum[11]\change{Change this!}
%\lipsum[11]\info{This can help me in chapter seven!}
%\lipsum[11]\improvement{This really needs to be improved!\newline\newline What was I thinking?!}
%\thiswillnotshow{This is hidden since option `disable' is chosen!}
%\improvement[inline]{The following section needs to be rewritten!}
%\lipsum[11]
%\newpage
%\listoftodos[Notes]

\section{Introduction}
\label{tH02_Introduction}
Paper Introduction

\section{Overview Sandboxing}
\label{tH02_Overview_Sandbox}
%Short Overview over the topic of sandboxing: explanation of general concepts, definition of status quo. Possibly pointing out current restrictions and weaknesses, which can be referenced in the following chapters
\todo[inline]{Sandboxing-Anwendung Isolation, Restriction for protection, but also behavioural analysis. Source for the necessity of sandboxing for malware analysis in advance of detection can be quoted from t02\_AASandbox. Signature Analysis and understanding of behaviour to allow future static analysis.}

Before we go into detail regarding the latest progression regarding sandboxing technology this section will give a brief overview of the general concepts of said technology and define the status quo as a baseline for later reference. In general, sandboxes allow the execution of a possibly malicious program in a controlled and monitored environment. Traditional use cases are the protection of the host system from unwanted alteration during the execution of an unknown, possibly malicious program or the detailed analysis of said programs behaviour to identify and gain information about new and hence unknown malware. A common approaches to achieve this is either monitoring, altering or intercepting system calls from the sandboxed program, depending on the relevant use case. 

\todo[inline]{kurzer Absatz über Programming language based sandboxes oder Web Sandboxes bzw. die Verwendung von Sandboxes zur Isolation von Anwendungen untereinander, bspw. bei der Integration in eine Website. Kurze Einführung zur *Ubiquity* dieser findet sich in t02\_Cappos, Retaining Sandbox Containement despite bugs...}

 If the alteration of the host system is not prevented, usually an additional mechanism like an encapsulating virtual machine is used to allow easy restoration of the system to its initial state. The sandbox is used to isolate the application from the system and controls its execution\cite{t02_Hoopes}[p. 68f].

There are several criteria that determine the quality of a sandbox and its applicability to a certain use case. The most obvious one is the execution performance of the sandboxed application. Monitoring its behaviour as well as intercepting and sanitizing performed system calls introduces a significant overhead which can result in notably longer execution time. This is not only impractical from a users perspective but also allows modern malware to recognize the sandboxed environment and evade detection by displaying benign behaviour\cite{NEEDED}. Hence it should be as low as possible. Furthermore, if the sandbox is used to isolate the encapsulated program, alteration of the host system and the possibility of escaping the sandbox should obviously be non-existent. In addition to these core-principles also the already mentioned resistance to detection of the sandboxed environment as well as the visibility or accuracy of the enclosed program execution can be of significant interest, especially when the sandbox is used for the behavioural analysis of malware \cite{t02_Kruegel}[p. 1]. These criteria will be referenced in later chapters to evaluate introduced techniques.\todo{weitere Kriterien?}

%Cites
% t02_Hoopes - Book, Virtualisation for Security
%t02_Kruegel - Paper, Full System Emulation

\section{Advances in OS-based sandboxing}
\label{tH02_OS_based}
\subsection{File-system layering on OS-level}
%One of the initially provided papers. Replication of the file system accessed by a sandboxed application not only allows the analysis and restriction of said possibly malicious program but in addition to that makes it possible to selectively commit changes to the real system. This introduces various new use-cases.

As presented in chapter \ref{tH02_Overview_Sandbox}, sandboxes offer a variety of helpful features regarding analysis and protection from malicious software. However, solutions focussing on isolating malware and protecting the host system - in contrast of such focussed on malware analysis -  usually completely prevent access to the hosts file system or only allow restricted access\cite{NEEDED}. However, allowing alteration of the hosts file system (albeit while still assuring protection) can be interesting for a multitude of use cases. Though at first glance this might sound contradictory, Kim and Zeldovich have developed a method to allow this, introduced in their sandboxing solution MBOX. Like similar sandboxes it offers protection from modification by malicious software and allows flexible control of the isolated program. However, instead of prohibiting or restricting file system access, relevant system calls  are intercepted [[using \textit{seccomp/BPF}]] and redirected to a virtualized separate file system, controlled by the sandbox. 
%This does not only effectively protect the host but also allows (selective) transfer of the performed changes back to the original file system.
From the host systems perspective, the simulated file system is stored as a regular directory and hence can easily be examined using regular Unix tools\cite{NEEDED}.\todo[inline]{Impact on security? Escaping the directory and accessing the host? Probable harm from retained execution?}

This approach introduces various new use cases apart from the common security related ones. For example, it allows users without root-priviledges to use the systems regular package managers to install software. This process usually would require root privileges to access system directories. However, by installing said packages in a simulated file system where a root-like environment can be emulated, it can also be performed by regular users. Other possible scenarios make use of the possibility to checkpoint the original file system, similar to the process of creating a new branch in versioning tools like GIT, e.g. while editing system configuration files. In case of a faulty setting, which would otherwise corrupt the system, changes can simply be discarded by rolling back to the original file system while successful changes can easily be applied. It even allows a profile-based sandboxing-approach where each sandboxed application is only provided with access to necessary files (see chapter \ref{tH02_SandboxProfiles} for more details).
 
 MBox is implemented as an extension of \textit{strace4.7} which was modified to take advantage of the seccomp\footnote{Secure Computing} / BPF\footnote{Berkeley Packet Filter} mechanisms available since Linux 3.5. While running a process in seccomp mode ultimately prohibits it from using more than a certain set of specified system calls, the extended support for BPF allows a more detailed examination of the calls in advance of their execution. This allows MBox to intercept and sanitize them if necessary by rewriting its arguments to point to the sandbox file system. To avoid unnecessary overhead, this mechanism is not invoked every time the BFP application intercepts a system call. Instead, it triggers an event to a tracer, which itself uses \textit{ptrace} to manipulate the arguments. If MBox is used on systems running a kernel older than 3.5 and seccomp / BFP is not available, it falls back to use solely \textit{strace}, which results in interception of all system calls performed by the application and hence a higher overhead.
 
 Performance overhead in general is highly dependent on the nature of the sandboxed application. Whereas sandboxing applications running mostly in user space\footnote{tested with Octave Benchmark} introduced only a minor overhead of 0.1\%, applications relying heavily on system calls, e.g. for file access\footnote{tested with Zip and Untar}, lead to a more significant overhead of 12 - 21.9\%.
 
 
\unsure[inline]{Naeher auf copy-on-write und TOCTOU Problematik eingehen}
\todo[inline]{Bewertung und Kritik}
  
 copy-on-write
 Concurrency Problematik
 Performance-improvements with Tracer
 


\subsection{Secure sandboxing despite bugs in memory-safe code}
%Extracting the standard libraries from one single trusted code based and isolating them from one another separated from the rest of the sandbox hinders exploitation of flaws present in those libraries and provides better isolation.
%t02_Cappos

It is in the nature of the general purpose of sandboxes - isolating possibly malicious software - that they play a crucial role for security in many of today's digital applications. Consequently, flaws in the construction of a sandbox that allow the isolated application to escape pose a vital risk to security. However, due to the general architecture of modern sandboxes, being completely bug-free is hard to guarantee. In general, sandboxes consist of three different components: the sandboxed untrusted application code, the interpreter for the core language the sandbox is written in and a large amount of standard libraries, which provide the general functionality. Parts of the latter are used to perform the critical operations that the sandbox restricts and mediates between the isolated application and the operating system and represent the trusted code base (TCB) of the sandbox. Accordingly, parts of those libraries have to be written in native code to access system resources, but in accordance to security-related best-practices, large parts of these libraries are written in memory-safe languages to increase security.\todo{Naeher auf memory safety eingehen?} However, according to \cite{NEEDED}\todo{Insert citation found in Cappos et al} even bugs in memory-safe code present a significant risk and possibly allow an attacker to escape the sandbox.

This shall be briefly illustrated at the example of the Java Sandbox, a technically secure memory-safe language. Java applications are not allowed to call native code directly, which is enforced by different components of the sandbox. Instead, this functionality is implemented as part of the standard libraries. The sensitive functions are classified as private and cannot be accessed directly as well, but instead are called through public wrapper functions that mediate and verify access and enforce a security policy. These sensitive functions however do pose a major security risk. Since Java libraries are organized as packages, objects may contain both privileged and unprivileged code as well as data members extending the scope to other files, effectively interlinking many packages. If any part of the large trusted code base is flawed, untrusted code may directly access sensitive native functions and hence undermines overall security.

To address this problem, Cappos et al. developed a sandbox technique that moderates the impact of a security failure in a standard library, implemented in a custom language subset of Python. They archived this by splitting the single TCB into multiple parts and moving as much functionality as possible out of the kernel into separate libraries. The sandbox itself is organised as a stack of isolated "` security layers"', each with a set of security-verified capabilities that allows controlled interaction. Each is instantiated by the layer beneath it, passing along at most a subset of its capabilities, with the kernel at the bottom of the stack. Since it keeps control over all its descendants, only a vulnerability in the kernel can compromise the sandbox in it entirety, otherwise a flaw in a layer may only affects its children.

This security layer design is implemented based on two XXXXXXXXXXXX. Two \textit{virtual namespace} calls provided by the kernel allow the validation and execution of dynamically added code at runtime to load the split-up libraries. The mandatory provided capability mapping ensures that the namespace does not contain any capability that wasn't explicitly granted. However, this does not enforce isolation between the libraries. This is ensured by the \textit{encasement library} which implements the layer abstraction between the libraries and is located right above the kernel in the architecture. To avoid shared objects or functions between the layers, only copies, created by the encasement library are passed between them. So called \textit{contracts} detail the capabilities of each layer and are used to filter and verify function calls that can be called by other layers, which are itself wrapped inside a verification function by the encasement library. If I violation is detected, the sandboxed program is terminated.

To provide functionality similar to other sandboxes while retaining the benefits from isolation, the kernel provides various capabilities spanning network functions, I/O calls, locking mechanisms as well as thread- and encryption-related calls that are provided to the untrusted layers building upon it. Using these, the authors built standard libraries providing the common language functionality in their Python derivative while following the isolation paradigm.\todo{include some sample functionality? ...like XML parsing, RPC, serialisation, whatever?}

To evaluate the benefits of isolating the libraries and excluding them from the trusted code base, the authors compared the impact of 30 known bugs of the Java Virtual Machine and how they would affect program execution in their sandbox, if the flawed components were translated and isolated in their sandbox. Since this evaluation is only of qualitative nature and highly subjective, each bug and its impact was also independently categorized by three additional authors and discussed until consensus was reached. It was found that at least six of eight applicable bugs that lead to the execution of arbitrary code in the JVM could have been prevented.
As with other sandbox implementations, impact on performance is considered as an additional factor for evaluation. Initializing security layers as well as encapsulating communication between them through the encasement library adds to the execution time. However, since these values only range from one to two-digit milliseconds they were found to be acceptable if not negligible. Despite execution time each security layer also adds a memory overhead needed for the contracts, wrappers as well as the duplication of passed arguments. On a system with a 64-bit memory address each layer consumed an additional 19kb of memory, which should be acceptable even for the most limited and lightweight devices.

Interesting approach, promising results, however : Security evaluation should be taken with a large grain of salt. Even though some were prevented, many cases were not applicable since no translation of the affected part possible. Method itself also questionable.

%Memory-safe code and proramming languages increase the safety of the code since applications should not be able to gain unauthorized access to priviledged sequences of the code / available libraries since it is impossible to exploit mistakes and bugs in memoty allocation, dangling pointers etc. 



\subsection{Safe Loading}
Replacing the standard application loader with a more security-focussed one and linking it with the sandbox to allow better fault isolation. This way, information about the application behaviour can be passed to the sandbox in advance of program execution.

\section{Advances in web-based sandboxing}
\label{tH02_Web_based}
\subsection{Software-based fault isolation for dynamic runtime-environments}
One of the initially provided papers. Introducing a method allowing effective software-based fault isolation and static code checks despite highly dynamic environments including just-in-time compilation and runtime code editing.
\subsection{Type-based verification of Web-sandbox security}
One of the initially provided papers. Introducing a method for a simplified functionality \& security verification of currently in development or new sandbox systems, based on codified qualities.
\subsection{Real-time analysis of websites}
Sandboxing entire websites to allow malware analysis even before the browser executes part of the code. (ADSandbox)

\section{Sandboxes in mobile environments}
\label{tH02_Mobile}
\subsection{Maybe: short motivation for sandboxing mobile applications}
Most of the current solution for sandboxing, especially for the purpose of dynamic malware analysis, are available for commodity desktop or server operating systems due to their longer availability and omnipresent application \cite{NEEDED}. With the rise of smartphones and other mobile devices and other mobile devices over last decade however, mobile operating systems like Google's Android and Apples iOS have become widely adopted. Due to their high popularity, people all over the world use them for a wide variety of tasks, ranging from cellular and web-based communication to security-critic actions like online banking. This, combined with the fact that many applications store personal and sensitive data locally on these phones and that it is possible to bill their owner, e.g. by calling premium numbers makes these devices prone to attacks by malicious software. Estimated numbers of 718 000 harmful applications as of 2013\cite{t02_TrendLabs} suggest that especially on the open-source android platform, which allows software to be installed from various sources, an effective mechanism to identify malicious software is key. Regarding the ever-growing amount of mobile applications the need for an effective, automated malware analysis tool to provide the necessary behavioural footprint and classification for mobile malware-detection becomes evident. However, due to differences between conventional and mobile operating systems and limitation of device capabilities, many tried and tested solutions are not applicable\cite{NEEDED}. Luckily over the last few years sandboxing solutions tailored to the needs of the mobile environment have emerged.  The following chapters will present some, implementing innovative functionality or novel approaches, in more detail.

\subsection{Static and dynamic analysis of Android applications on Java- and kernel-level}
\subsection{Sandbox-profiles for Apple iOS}
\label{tH02_SandboxProfiles}
Extending Apples native sandboxing concept by introducing sandbox profiles for different applications to improve individual security.


\section{Advances regarding sandbox evasion}
wird wohl gestrichen
\label{tH02_Evasion}
Note: the topics in this chapter and the supporting papers sound promising, however some of them might focus solely on malware detection rather than sandboxing techniques and will be discarded. The section about "`Transparent Sandboxing"' will then be inserted in chapter \ref{tH02_OS_based}.
\subsection{Maybe: Shift of malware behaviour regarding sandbox detection}
Addressing the question of how relevant (or not) the topic of sandbox detection and hence, measures against it are, regarding the shift in system architectures caused by the growing  availability of cloud-based / virtualized systems,
\subsection{Transparent sandboxing for evasive malware}
\subsection{Maybe: Sandbox-Evasion on mobile Systems}

\section{R\'{e}sum\'{e} and Conclusion}
\label{tH02_Conclusion}
%%
% F�r Flattersatz in Tabellenspalten:
% \newcolumntype{z}{>{\PBS{\raggedright\hspace{0pt}}}p{5cm}}
% statt p{5cm} einfach z verwenden, z.B. \begin{tabular}{|l||c|r|z|}
% F�r graue Tabellenspalten (z.B. zentrierter Text):
% \newcolumntype{g}{>{\columncolor[gray]{0.8}}c} % grau
% \newcolumntype{G}{>{\columncolor[gray]{0.9}}c} % helleres grau
% \begin{tabular}{|l||c|G|g|} oder auch \multicolumn{4}{|g|}{Eine ganze Zeile}
% Aber Achtung: Im xdvi werden graue Zeilen nicht korrekt dargestellt, erst
% im PostScript- oder PDF-Dokument bzw. Ghostview.
%
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
% Bitte keinen Text mehr unterhalb dieser Zeile eintragen!!
% -----------------------------------------------------------------------------
%
% --> �blicherweise wird nur die Literatur aufgelistet, die auch referenziert
%     wird. M�chte man auch nichtreferenzierte Literatur einschlie�en, so
%     koennte man dies mit \nocite{<citelabel>} tun (ist jedoch schlechter
%     Stil und soll daher hier nicht gemacht werden).
%\nocite{*}
%     In die folgende Zeile sollte die ben�tigte Literaturdatenbankdatei
%     eingetragen werden (im Normalfall nicht zu �ndern):
\bibliography{tH02_txt}
%
\docend
%%% end of document
